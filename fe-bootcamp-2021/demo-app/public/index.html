<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
    <script>

      // const outer = () => {

      //   let t = 2;
      //   console.log("called outer");

      //   setTimeout(function firstTimeout() {
      //     t = 4;
      //     console.log("first timeout")
      //   }, 2000);

      //   return function inner() {
      //     console.log(t);
      //   };
      // };

      // const inner = outer();

      // inner();

      // setTimeout(function secondTimeout(){
      //   inner();
      //   console.log("first timeout")
      // }, 4000)

      // // console.dir(inner);

      // setTimeout(() => {
      //   console.log("a");
      // }, 0);

      // console.log("b");

      //const delay = () => Math.floor(Math.random() * 1000) + 500;

      // setTimeout(() => {
      //   console.log("a");
      //   setTimeout(() => {
      //     console.log("b");
      //     setTimeout(() => {
      //       console.log("c");
      //     }, delay());
      //   }, delay());
      // }, delay());

      // Lab Exercise

      // 1. Run the allDone function after all 3 setTimeout callbacks execute
      // 2. The call to all 3 setTimeouts must be done in the first task
      // 3. You can modify the code however you want except for the following:
        // - No promises
        // - The console logs for a, b, c must run in different tasks
/*  
      function allDone() {
        console.log('all done');
      }

    
      setTimeout(() => {
        console.log('a1');

        setTimeout(() => {
          console.log('b1');
          setTimeout(() => {
            console.log('c1');

            allDone();
          }, delay());              
        
        }, delay());


      }, delay());      


      let callbackCounter = 3;
      function amIDone () {
        callbackCounter--;
        console.log('callbackCounter:',callbackCounter);
        if ( callbackCounter === 0 ) return true;
        return false;
      }

      setTimeout(() => {
        console.log('a2');
        //due to closure, if will be updating same var
        amIDone() && allDone();
      }, delay());

      setTimeout(() => {
        console.log('b2');
        //due to closure, if will be updating same var
        amIDone() && allDone();
      }, delay());

      setTimeout(() => {
        console.log('c2');
        //due to closure, if will be updating same var
        amIDone() && allDone();
      }, delay());

      const taskA = () => new Promise(resolve => setTimeout(() => resolve('a'), delay()));
      const taskB = () => new Promise(resolve => setTimeout(() => resolve('b'), delay()));
      const taskC = () => new Promise(resolve => setTimeout(() => resolve('c'), delay()));

      Promise.all([taskA(), taskB(), taskC()]).then(results => {
        console.log("all done");
        console.log(results);
      });            
*/
    </script>

    <script>
/*
      //make Ajax call using JS
      //XHR and fetch api's
      //XHR from Microsoft
      const xhr = new XMLHttpRequest();
      xhr.addEventListener("readystatechange", () => {
        if (xhr.status === 200 && xhr.readyState === 4) {
          console.log("response::",JSON.parse(xhr.responseText));
        }
      });

      xhr.open("GET", "http://localhost:3060/cars");
      xhr.send();
*/

/*
      p.then( cars => {
        console.log("response after Promoise::",cars);
      })
      .catch(errorMessage => {
        console.log("errorMessage::",errorMessage);
      });
*/
/*
      function myFetch (url) {
        return new Promise( (resolve,reject) => {
          const xhr = new XMLHttpRequest();
          xhr.addEventListener("readystatechange", () => {
            if (xhr.readyState === 4) { //is it done
              if ( xhr.status === 200 ) //is it done & successful
                resolve(JSON.parse(xhr.responseText));
              else //its done & failed (other than 200 status code)
              reject("error with status code:"+xhr.status);
            }
            else { // still processing
              //reject("error with status code:"+xhr.status);
              console.log("still processing ....")
            }
          });

          //TODO:: might have to look for httpMethod and handle it differently get/post etc.
          xhr.open("GET", url);
          xhr.send();        
        });        

      };

      myFetch("http://localhost:3060/cars").then( cars => {
        console.log("cars:",cars);
      })
      .catch(errorMessage => {
        console.log("errorMessage ==>",errorMessage);
      });


      myFetch("http://localhost:3060/colors").then( colors => {
        console.log("colors:",colors);
        colors.forEach( color => {
          myFetch(`http://localhost:3060/colors/${color.id}`).then( color => {
          //myFetch("http://localhost:3060/colors/1").then( color => {
            console.log("color =>", color);
          })
          .catch(errorMessage => {
            console.log("errorMessage ==>",errorMessage);
          });    
        });  
      })
      .catch(errorMessage => {
        console.log("errorMessage ==>",errorMessage);
      });      
then()
      myFetch("http://localhost:3060/colors").then( colors => {
        //console.log("colors:",colors);
        const promises = colors.map( color => {
          return myFetch(`http://localhost:3060/colors/${color.id}`); //return a promise
        });

        //console.log(promises);

        Promise.all(promises).then(results => { //resolve all the promises
          console.log("all done");
          console.log(results);
        });        
      })
      .catch(errorMessage => {
        console.log("errorMessage ==>",errorMessage);
      });      
*/
/*

      //fetch api
      fetch("http://localhost:3060/cars")
        .then( res => res.json()) //res.json is an async vs JSON.parse is a sync process, res.json() not using main thread
        .then( cars => console.log(cars));

        fetch("http://localhost:3060/cars/1")
        .then( res => res.json()) //res.json is an async vs JSON.parse is a sync process, res.json() not using main thread
        .then( car => console.log(car));

        //add a car
        fetch("http://localhost:3060/cars", { //options obj
          method: 'POST',
          headers: { 'Content-Type': 'application/json'},
          body: JSON.stringify( {
            make: 'Nissan', model: 'Pathfinder', 
            color: 'RED', year: 2021, price: 45000
          }),
        })
        .then( res => {
          for (let key of res.headers.keys()) {
            console.log("header ",key," : ",res.headers.get(key));
          }
          res.json(); //res.json is an async vs JSON.parse is a sync process, res.json() not using main thread
        })
        .then( car => console.log("New Car:",car));        

/*        
        //replace
        fetch("http://localhost:3060/cars/4", { //options obj
          method: 'PUT',
          headers: { 'Content-Type': 'application/json'},
          body: JSON.stringify( {
            make: 'Nissan', model: 'Pathfinder', 
            color: 'Blue', year: 2020, price: 42000
          }),
        });
        

        //delete
        fetch("http://localhost:3060/cars/3", { //options obj
          method: 'DELETE',
        });


        const carId = 5;
        //replace
        fetch(`http://localhost:3060/cars/${carId}`, { //options obj
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json'},
          body: JSON.stringify( {
            model: 'Morana', 
          }),
        });        
*/
    </script>
  </body>
</html>
